package es.tfg.votacion.service;

import es.tfg.votacion.config.FabricProperties;
import es.tfg.votacion.model.ElectionStatus;
import org.hyperledger.fabric.client.*;
import org.hyperledger.fabric.client.identity.*;
import org.hyperledger.fabric.protos.gateway.ErrorDetail;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import jakarta.annotation.PostConstruct;
import jakarta.annotation.PreDestroy;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.InvalidKeyException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.util.Map;
import java.util.HashMap;
import java.util.concurrent.TimeUnit;

import io.grpc.Grpc;
import io.grpc.ManagedChannel;
import io.grpc.TlsChannelCredentials;

/**
 * Servicio para comunicación con Hyperledger Fabric
 * 
 * Gestiona:
 * - Conexión con la red Fabric usando Gateway SDK
 * - Invocación de chaincode para registro de votos
 * - Consultas de estado del ledger
 * - Manejo de timeouts y reintentos con backoff exponencial
 * 
 * @author Enrique Huet Adrover
 * @version 1.0
 * @since Java 21
 */
@Service
public class FabricService {

    private static final Logger logger = LoggerFactory.getLogger(FabricService.class);

    @Autowired
    private FabricProperties fabricProperties;

    private Gateway gateway;
    private Contract contract;
    private ManagedChannel channel;
    private boolean mockMode = false; 

    /**
     * Inicializa la conexión con la red Hyperledger Fabric después de construir el bean
     */
    @PostConstruct
    public void initializeConnection() {
        try {
            logger.info("Initializing Hyperledger Fabric Gateway connection");
            initGateway();
            logger.info("Successfully connected to Hyperledger Fabric network");
        } catch (Exception e) {
            logger.error("Failed to initialize Fabric connection: {}", e.getMessage(), e);
            // En un entorno de producción, podríamos lanzar una excepción aquí
            // Para el PoC, continuamos sin conexión blockchain
            mockMode = true;
        }
    }

    /**
     * Cierra la conexión con el Gateway al destruir el bean
     */
    @PreDestroy
    public void cleanup() {
        closeGateway();
    }

    /**
     * Inicializa la conexión con la red Hyperledger Fabric
     * 
     * @throws Exception si no se puede establecer la conexión
     */
    private void initGateway() throws Exception {
        try {
            logger.info("Attempting to connect to Fabric network...");
            logger.debug("Connection profile: {}", fabricProperties.getConnectionProfile());
            logger.debug("Wallet path: {}", fabricProperties.getWalletPath());
            logger.debug("User: {}", fabricProperties.getUser());
            logger.debug("Channel: {}", fabricProperties.getChannel());
            logger.debug("Chaincode: {}", fabricProperties.getChaincode());
            
            // Load identity from file system (simulating wallet)
            // In a real scenario, we would use the Wallet API, but for this PoC with Gateway SDK 1.x
            // we load the cert and key directly from the crypto materials generated by the test network
            
            // Path to crypto materials (hardcoded for PoC based on test-network structure)
            // We assume the backend is running on the same machine as the test network
            String cryptoPath = "/home/ehuetadr/TFG/VotacionBC/fabric/test-network/organizations/peerOrganizations/org1.example.com";
            String certPath = cryptoPath + "/users/User1@org1.example.com/msp/signcerts/User1@org1.example.com-cert.pem";
            String keyPath = cryptoPath + "/users/User1@org1.example.com/msp/keystore/";
            
            // Find the private key file (it has a random name)
            Path keyDir = Paths.get(keyPath);
            Path privateKeyPath = Files.list(keyDir).findFirst().orElseThrow(() -> new RuntimeException("No private key found"));
            
            X509Certificate certificate = readX509Certificate(Paths.get(certPath));
            java.security.PrivateKey privateKey = getPrivateKey(privateKeyPath);
            
            Identity identity = new X509Identity("Org1MSP", certificate);
            Signer signer = Signers.newPrivateKeySigner(privateKey);
            
            // Create gRPC channel
            String peerEndpoint = "localhost:7051";
            String tlsCertPath = cryptoPath + "/peers/peer0.org1.example.com/tls/ca.crt";
            
            channel = Grpc.newChannelBuilder(peerEndpoint, TlsChannelCredentials.newBuilder()
                    .trustManager(Paths.get(tlsCertPath).toFile())
                    .build())
                    .build();
            
            // Create Gateway
            Gateway.Builder builder = Gateway.newInstance()
                    .identity(identity)
                    .signer(signer)
                    .connection(channel)
                    .evaluateOptions(options -> options.withDeadlineAfter(5, TimeUnit.SECONDS))
                    .endorseOptions(options -> options.withDeadlineAfter(15, TimeUnit.SECONDS))
                    .submitOptions(options -> options.withDeadlineAfter(5, TimeUnit.SECONDS))
                    .commitStatusOptions(options -> options.withDeadlineAfter(1, TimeUnit.MINUTES));
            
            gateway = builder.connect();
            
            // Get network and contract
            Network network = gateway.getNetwork(fabricProperties.getChannel());
            contract = network.getContract(fabricProperties.getChaincode());
            
            logger.info("Successfully connected to Fabric network");
            mockMode = false;
            
        } catch (Exception e) {
            logger.error("Failed to initialize Fabric gateway: {}", e.getMessage());
            throw new RuntimeException("Failed to connect to Fabric network", e);
        }
    }
    
    private static X509Certificate readX509Certificate(final Path certificatePath) throws IOException, CertificateException {
        try (var reader = Files.newBufferedReader(certificatePath, StandardCharsets.UTF_8)) {
            return Identities.readX509Certificate(reader);
        }
    }

    private static java.security.PrivateKey getPrivateKey(final Path privateKeyPath) throws IOException, InvalidKeyException {
        try (var reader = Files.newBufferedReader(privateKeyPath, StandardCharsets.UTF_8)) {
            return Identities.readPrivateKey(reader);
        }
    }

    /**
     * Crea una nueva elección en la blockchain
     * 
     * @param electionId ID de la elección
     * @return ID de transacción
     */
    public String createElection(String electionId) {
        logger.info("Creating election on blockchain: {}", electionId);
        
        if (!isConnected()) {
            logger.warn("No blockchain connection available, skipping blockchain creation");
            return "MOCK-TX-CREATE-" + electionId;
        }

        return executeWithRetry(() -> {
            try {
                byte[] result = contract.submitTransaction("createElection", electionId);
                // The chaincode returns the Election object as JSON, but we just need to know it succeeded
                // We can return the transaction ID if we want, but for now just success
                logger.info("Election created successfully on blockchain: {}", electionId);
                return "TX-CREATE-" + electionId;
                
            } catch (Exception e) {
                logger.error("Failed to create election on blockchain: {}", e.getMessage());
                throw new RuntimeException("Failed to create election", e);
            }
        }, "createElection");
    }

    /**
     * Emite un voto en la blockchain registrando el commitment
     * 
     * @param commitment Hash del voto cifrado
     * @param electionId ID de la elección
     * @return ID de transacción en el ledger
     * @throws RuntimeException si la operación falla
     */
    public String emitVote(String commitment, String electionId) {
        logger.info("Emitting vote commitment to blockchain - Election: {}, Commitment: {}", electionId, commitment);
        
        if (!isConnected()) {
            logger.warn("No blockchain connection available, returning mock transaction ID");
            return "MOCK-TX-" + electionId + "-" + System.currentTimeMillis();
        }

        return executeWithRetry(() -> {
            try {
                byte[] result = contract.submitTransaction("emitVote", electionId, commitment);
                // The chaincode returns the txId, but submitTransaction returns the result payload
                // Our chaincode returns txId as string
                String transactionId = new String(result, StandardCharsets.UTF_8);
                
                logger.info("Vote emitted successfully. TX-ID: {}", transactionId);
                return transactionId;
                
            } catch (Exception e) {
                logger.error("Failed to emit vote to blockchain: {}", e.getMessage());
                throw new RuntimeException("Failed to submit vote transaction", e);
            }
        }, "emitVote");
    }

    /**
     * Cierra una elección en la blockchain
     * 
     * @param electionId ID de la elección a cerrar
     * @return Resultado del cierre con estadísticas
     */
    public Map<String, Object> closeElection(String electionId) {
        logger.info("Closing election on blockchain: {}", electionId);
        
        if (!isConnected()) {
            logger.warn("No blockchain connection available, returning mock result");
            return createMockElectionResult(electionId);
        }

        return executeWithRetry(() -> {
            try {
                byte[] result = contract.submitTransaction("closeElection", electionId);
                String resultJson = new String(result, StandardCharsets.UTF_8);
                
                // Parse JSON result (simple parsing for PoC)
                // In production use Jackson
                Map<String, Object> electionResult = new HashMap<>();
                electionResult.put("electionId", electionId);
                electionResult.put("status", "CLOSED");
                electionResult.put("timestamp", System.currentTimeMillis());
                electionResult.put("rawResult", resultJson);
                
                return electionResult;
                
            } catch (Exception e) {
                logger.error("Failed to close election on blockchain: {}", e.getMessage());
                throw new RuntimeException("Failed to close election", e);
            }
        }, "closeElection");
    }

    /**
     * Obtiene el recuento de votos desde la blockchain
     * 
     * @param electionId ID de la elección
     * @return Resultados agregados de la votación
     */
    public Map<String, Object> countVotes(String electionId) {
        logger.info("Counting votes from blockchain for election: {}", electionId);
        
        if (!isConnected()) {
            logger.warn("No blockchain connection available, returning mock results");
            return createMockVoteResults(electionId);
        }

        return executeWithRetry(() -> {
            try {
                byte[] result = contract.evaluateTransaction("getElection", electionId);
                String resultJson = new String(result, StandardCharsets.UTF_8);
                
                // We need to parse the JSON to get totalVotes
                // For now, we just return the raw result in the map
                // In a real app, we would use Jackson to deserialize to Election object
                
                Map<String, Object> voteResults = new HashMap<>();
                voteResults.put("electionId", electionId);
                voteResults.put("rawResult", resultJson);
                // Extract totalVotes from JSON string manually for PoC
                // {"electionId":"...","status":"...","totalVotes":123}
                int totalVotes = 0;
                if (resultJson.contains("\"totalVotes\":")) {
                    String temp = resultJson.substring(resultJson.indexOf("\"totalVotes\":") + 13);
                    if (temp.contains("}")) {
                        temp = temp.substring(0, temp.indexOf("}"));
                    }
                    if (temp.contains(",")) {
                        temp = temp.substring(0, temp.indexOf(","));
                    }
                    try {
                        totalVotes = Integer.parseInt(temp.trim());
                    } catch (NumberFormatException e) {
                        logger.warn("Failed to parse totalVotes: {}", temp);
                    }
                }
                
                voteResults.put("totalVotes", totalVotes);
                voteResults.put("timestamp", System.currentTimeMillis());
                
                return voteResults;
                
            } catch (Exception e) {
                logger.error("Failed to count votes from blockchain: {}", e.getMessage());
                throw new RuntimeException("Failed to count votes", e);
            }
        }, "countVotes");
    }

    /**
     * Consulta el estado de una elección en la blockchain
     * 
     * @param electionId ID de la elección
     * @return Estado actual de la elección
     */
    public ElectionStatus queryElectionStatus(String electionId) {
        logger.debug("Querying election status: {}", electionId);
        
        if (!isConnected()) {
            logger.warn("No blockchain connection available, returning default status");
            return ElectionStatus.ACTIVE; 
        }

        return executeWithRetry(() -> {
            try {
                byte[] result = contract.evaluateTransaction("getElection", electionId);
                String resultJson = new String(result, StandardCharsets.UTF_8);
                
                if (resultJson.contains("\"status\":\"CLOSED\"")) {
                    return ElectionStatus.CLOSED;
                } else if (resultJson.contains("\"status\":\"ACTIVE\"")) {
                    return ElectionStatus.ACTIVE;
                }
                
                return ElectionStatus.ACTIVE;
                
            } catch (Exception e) {
                logger.error("Failed to query election status: {}", e.getMessage());
                // If election not found, it might be DRAFT or not created yet
                return ElectionStatus.DRAFT;
            }
        }, "queryElectionStatus");
    }

    /**
     * Verifica que un voto fue registrado correctamente
     * 
     * @param transactionId ID de transacción del voto
     * @return true si el voto está en el ledger
     */
    public boolean verifyVoteTransaction(String transactionId) {
        logger.debug("Verifying vote transaction: {}", transactionId);
        
        if (!isConnected()) {
            logger.warn("No blockchain connection available, using mock verification");
            boolean isValid = transactionId != null && 
                            (transactionId.startsWith("TX-") || transactionId.startsWith("MOCK-TX-"));
            return isValid;
        }

        return executeWithRetry(() -> {
            try {
                byte[] result = contract.evaluateTransaction("verifyTransaction", transactionId);
                String verification = new String(result, StandardCharsets.UTF_8);
                return "true".equals(verification);
                
            } catch (Exception e) {
                logger.error("Failed to verify transaction: {}", e.getMessage());
                return false;
            }
        }, "verifyVoteTransaction");
    }

    /**
     * Verifica si hay conexión activa con la blockchain
     * 
     * @return true si está conectado (en modo mock siempre false para usar fallbacks)
     */
    public boolean isConnected() {
        if (mockMode) {
            return false; 
        }
        return gateway != null && contract != null;
    }

    /**
     * Cierra la conexión con el Gateway
     */
    public void closeGateway() {
        if (gateway != null) {
            try {
                logger.info("Closing Fabric Gateway connection");
                gateway.close();
                gateway = null;
                contract = null;
            } catch (Exception e) {
                logger.error("Error closing gateway: {}", e.getMessage());
            }
        }
        if (channel != null) {
            try {
                channel.shutdownNow().awaitTermination(5, TimeUnit.SECONDS);
                channel = null;
            } catch (InterruptedException e) {
                logger.error("Error closing channel: {}", e.getMessage());
            }
        }
    }

    /**
     * Ejecuta una operación con reintentos y backoff exponencial
     * 
     * @param operation   Operación a ejecutar
     * @param operationName Nombre para logging
     * @return Resultado de la operación
     */
    private <T> T executeWithRetry(java.util.function.Supplier<T> operation, String operationName) {
        int maxAttempts = fabricProperties.getRetry().getMaxAttempts();
        long backoffDelayMs = fabricProperties.getRetry().getBackoffDelayMs();
        
        for (int attempt = 1; attempt <= maxAttempts; attempt++) {
            try {
                return operation.get();
            } catch (Exception e) {
                // Unwrap RuntimeException if it wraps a Fabric exception (since Supplier can't throw checked exceptions)
                Throwable cause = e;
                if (e instanceof RuntimeException && e.getCause() != null) {
                    cause = e.getCause();
                }

                // Extract detailed error message from EndorseException or SubmitException
                String detailedMsg = cause.getMessage();
                if (cause instanceof EndorseException) {
                    EndorseException ee = (EndorseException) cause;
                    if (!ee.getDetails().isEmpty()) {
                        // Combine all error details
                        StringBuilder sb = new StringBuilder();
                        for (ErrorDetail detail : ee.getDetails()) {
                            sb.append(detail.getMessage()).append("; ");
                        }
                        detailedMsg = sb.toString();
                        logger.error("EndorseException details: {}", detailedMsg);
                    }
                } else if (cause instanceof SubmitException) {
                    SubmitException se = (SubmitException) cause;
                    if (!se.getDetails().isEmpty()) {
                        StringBuilder sb = new StringBuilder();
                        for (ErrorDetail detail : se.getDetails()) {
                            sb.append(detail.getMessage()).append("; ");
                        }
                        detailedMsg = sb.toString();
                        logger.error("SubmitException details: {}", detailedMsg);
                    }
                }

                // Check for non-retriable errors (business logic errors from chaincode)
                if (detailedMsg != null && (
                    detailedMsg.contains("already voted") || 
                    detailedMsg.contains("does not exist")
                )) {
                    logger.error("Non-retriable error in {}: {}", operationName, detailedMsg);
                    throw new RuntimeException(detailedMsg, cause); // Don't retry business logic errors
                }

                if (attempt == maxAttempts) {
                    logger.error("Operation {} failed after {} attempts: {}", operationName, maxAttempts, cause.getMessage());
                    throw new RuntimeException("Operation failed after retries: " + detailedMsg, cause);
                }
                
                logger.warn("Attempt {}/{} for {} failed, retrying in {}ms: {}", 
                    attempt, maxAttempts, operationName, backoffDelayMs, cause.getMessage());
                
                try {
                    Thread.sleep(backoffDelayMs);
                    backoffDelayMs *= 2; // Backoff exponencial
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                    throw new RuntimeException("Operation interrupted", ie);
                }
            }
        }
        
        throw new RuntimeException("Should not reach here");
    }

    /**
     * Crea resultado mock para elección cerrada (fallback cuando no hay conexión)
     */
    private Map<String, Object> createMockElectionResult(String electionId) {
        Map<String, Object> result = new HashMap<>();
        result.put("electionId", electionId);
        result.put("status", "CLOSED");
        result.put("timestamp", System.currentTimeMillis());
        result.put("mockMode", true);
        return result;
    }

    /**
     * Crea resultados mock de votación (fallback cuando no hay conexión)
     */
    private Map<String, Object> createMockVoteResults(String electionId) {
        Map<String, Object> result = new HashMap<>();
        result.put("electionId", electionId);
        result.put("totalVotes", 0);
        result.put("timestamp", System.currentTimeMillis());
        result.put("mockMode", true);
        return result;
    }
}