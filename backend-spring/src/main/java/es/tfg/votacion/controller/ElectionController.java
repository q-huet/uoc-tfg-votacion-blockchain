package es.tfg.votacion.controller;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import es.tfg.votacion.dto.*;
import es.tfg.votacion.model.CreateElectionRequest;
import es.tfg.votacion.model.Election;
import es.tfg.votacion.model.ElectionStatus;
import es.tfg.votacion.model.Receipt;
import es.tfg.votacion.model.User;
import es.tfg.votacion.service.AuthService;
import es.tfg.votacion.service.ElectionService;
import es.tfg.votacion.service.FabricService;
import es.tfg.votacion.service.StorageService;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.validation.Valid;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.security.MessageDigest;
import java.time.Instant;
import java.time.LocalDateTime;
import java.util.*;

/**
 * Controlador para gestión de elecciones y votaciones
 * 
 * Endpoints:
 * - GET /api/v1/elections - Lista elecciones activas
 * - GET /api/v1/elections/{id} - Detalle de elección
 * - POST /api/v1/elections/{id}/vote - Emitir voto
 * - POST /api/v1/elections/{id}/close - Cerrar votación (ADMIN)
 * - GET /api/v1/elections/{id}/results - Obtener resultados (ADMIN/AUDITOR)
 * - POST /api/v1/elections - Crear elección (ADMIN)
 * 
 * @author Enrique Huet Adrover
 * @version 1.0
 * @since Java 21
 */
@RestController
@RequestMapping("/elections")
@CrossOrigin(origins = { "http://localhost:4200", "http://127.0.0.1:4200" })
public class ElectionController {

    private static final Logger logger = LoggerFactory.getLogger(ElectionController.class);
    
    private final AuthService authService;
    private final ElectionService electionService;
    private final FabricService fabricService;
    private final StorageService storageService;
    private final ObjectMapper objectMapper;

    public ElectionController(
            AuthService authService,
            ElectionService electionService,
            FabricService fabricService,
            StorageService storageService) {
        this.authService = authService;
        this.electionService = electionService;
        this.fabricService = fabricService;
        this.storageService = storageService;
        this.objectMapper = new ObjectMapper();
    }

    /**
     * Crear una nueva elección (ADMIN)
     * POST /api/v1/elections
     */
    @PostMapping
    public ResponseEntity<?> createElection(
            @Valid @RequestBody CreateElectionRequest createRequest,
            @RequestHeader(value = "Authorization", required = false) String authHeader,
            HttpServletRequest request) {
        
        logger.info("Creating new election: {}", createRequest.title());
        
        User user = validateAdminAccess(authHeader, request);
        if (user == null) {
            return ResponseEntity
                .status(HttpStatus.FORBIDDEN)
                .body(new ErrorResponse(
                    403,
                    "Forbidden",
                    "Admin access required",
                    request.getRequestURI()
                ));
        }

        // Validate dates
        if (createRequest.endTime().isBefore(createRequest.startTime())) {
             return ResponseEntity
                .status(HttpStatus.BAD_REQUEST)
                .body(new ErrorResponse(
                    400,
                    "Bad Request",
                    "End time must be after start time",
                    request.getRequestURI()
                ));
        }
        
        String id = "election-" + UUID.randomUUID().toString().substring(0, 8);
        
        Election election = new Election(
            id,
            createRequest.title(),
            createRequest.description(),
            createRequest.options(),
            ElectionStatus.ACTIVE, // Default to ACTIVE for simplicity in this POC
            createRequest.startTime(),
            createRequest.endTime(),
            user.username(),
            LocalDateTime.now(),
            0,
            1,
            false,
            true,
            null // Public Key will be generated by service
        );
        
        ElectionCreationResult result = electionService.createElection(election);
        
        return ResponseEntity
            .status(HttpStatus.CREATED)
            .body(result);
    }

    /**
     * Lista todas las elecciones activas
     * GET /api/v1/elections
     * 
     * @param authHeader Authorization header con JWT
     * @param request HTTP request para logging
     * @return Lista de elecciones disponibles
     */
    @GetMapping
    public ResponseEntity<?> getActiveElections(
            @RequestHeader(value = "Authorization", required = false) String authHeader,
            HttpServletRequest request) {
        
        logger.info("Fetching active elections from IP: {}", request.getRemoteAddr());
        
        // Validar autenticación (opcional para ver lista)
        final User currentUser;
        if (authHeader != null && authHeader.startsWith("Bearer ")) {
            String token = authHeader.substring(7);
            currentUser = authService.validateJwtToken(token);
        } else {
            currentUser = null;
        }
        
        try {
            List<Election> elections = electionService.getActiveElections();
            
            List<ElectionResponse> response = elections.stream()
                .map(election -> {
                    boolean hasVoted = currentUser != null && 
                        electionService.hasUserVoted(election.id(), currentUser.id());
                    
                    if (currentUser != null) {
                        logger.info("Checking vote status for user {} in election {}: hasVoted={}", 
                            currentUser.username(), election.id(), hasVoted);
                    }

                    return ElectionResponse.fromElection(
                        election, 
                        hasVoted, 
                        election.totalVotes()
                    );
                })
                .toList();
            
            logger.info("Returning {} active elections", response.size());
            
            return ResponseEntity.ok()
                .header("Cache-Control", "no-cache, no-store, must-revalidate")
                .header("Pragma", "no-cache")
                .header("Expires", "0")
                .body(response);
            
        } catch (Exception e) {
            logger.error("Error fetching elections", e);
            return ResponseEntity
                .status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(new ErrorResponse(
                    500,
                    "Internal Server Error",
                    "Error fetching elections",
                    request.getRequestURI()
                ));
        }
    }

    /**
     * Lista todas las elecciones (ADMIN)
     * GET /api/v1/elections/all
     * 
     * @param authHeader Authorization header con JWT
     * @param request HTTP request para logging
     * @return Lista de todas las elecciones
     */
    @GetMapping("/all")
    public ResponseEntity<?> getAllElections(
            @RequestHeader(value = "Authorization", required = false) String authHeader,
            HttpServletRequest request) {
        
        logger.info("Fetching all elections (ADMIN) from IP: {}", request.getRemoteAddr());
        
        User user = validateAdminAccess(authHeader, request);
        if (user == null) {
            return ResponseEntity
                .status(HttpStatus.FORBIDDEN)
                .body(new ErrorResponse(
                    403,
                    "Forbidden",
                    "Admin access required",
                    request.getRequestURI()
                ));
        }
        
        try {
            List<Election> elections = electionService.getAllElections();
            
            List<ElectionResponse> response = elections.stream()
                .map(election -> ElectionResponse.fromElection(
                    election, 
                    false, // Admin doesn't need to know if they voted in this view
                    election.totalVotes()
                ))
                .toList();
            
            logger.info("Returning {} elections", response.size());
            
            return ResponseEntity.ok()
                .header("Cache-Control", "no-cache, no-store, must-revalidate")
                .header("Pragma", "no-cache")
                .header("Expires", "0")
                .body(response);
            
        } catch (Exception e) {
            logger.error("Error fetching all elections", e);
            return ResponseEntity
                .status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(new ErrorResponse(
                    500,
                    "Internal Server Error",
                    "Error fetching elections",
                    request.getRequestURI()
                ));
        }
    }

    /**
     * Obtiene detalle de una elección específica
     * GET /api/v1/elections/{id}
     * 
     * @param electionId ID de la elección
     * @param authHeader Authorization header con JWT
     * @param request HTTP request
     * @return Detalle de la elección
     */
    @GetMapping("/{id}")
    public ResponseEntity<?> getElectionById(
            @PathVariable("id") String electionId,
            @RequestHeader(value = "Authorization", required = false) String authHeader,
            HttpServletRequest request) {
        
        logger.info("Fetching election: {}", electionId);
        
        User user = null;
        if (authHeader != null && authHeader.startsWith("Bearer ")) {
            String token = authHeader.substring(7);
            user = authService.validateJwtToken(token);
        }
        
        Optional<Election> electionOpt = electionService.getElectionById(electionId);
        
        if (electionOpt.isEmpty()) {
            return ResponseEntity
                .status(HttpStatus.NOT_FOUND)
                .body(new ErrorResponse(
                    404,
                    "Not Found",
                    "Election not found: " + electionId,
                    request.getRequestURI()
                ));
        }
        
        Election election = electionOpt.get();
        boolean hasVoted = user != null && 
            electionService.hasUserVoted(election.id(), user.id());
        
        ElectionResponse response = ElectionResponse.fromElection(
            election, 
            hasVoted, 
            election.totalVotes()
        );
        
        return ResponseEntity.ok()
            .header("Cache-Control", "no-cache, no-store, must-revalidate")
            .header("Pragma", "no-cache")
            .header("Expires", "0")
            .body(response);
    }

    /**
     * Emitir voto en una elección
     * POST /api/v1/elections/{id}/vote
     * 
     * @param electionId ID de la elección
     * @param voteRequest Datos del voto
     * @param authHeader Authorization header con JWT
     * @param request HTTP request
     * @return Recibo del voto (commitment + txId)
     */
    @PostMapping("/{id}/vote")
    public ResponseEntity<?> emitVote(
            @PathVariable("id") String electionId,
            @Valid @RequestBody VoteSubmissionRequest voteRequest,
            @RequestHeader(value = "Authorization", required = false) String authHeader,
            HttpServletRequest request) {
        
        logger.info("Vote submission for election: {}", electionId);
        
        // Validar autenticación
        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            return ResponseEntity
                .status(HttpStatus.UNAUTHORIZED)
                .body(new ErrorResponse(
                    401,
                    "Unauthorized",
                    "Authentication required",
                    request.getRequestURI()
                ));
        }
        
        String token = authHeader.substring(7);
        User user = authService.validateJwtToken(token);
        
        if (user == null) {
            return ResponseEntity
                .status(HttpStatus.UNAUTHORIZED)
                .body(new ErrorResponse(
                    401,
                    "Unauthorized",
                    "Invalid or expired token",
                    request.getRequestURI()
                ));
        }
        
        // Validar que la elección existe
        Optional<Election> electionOpt = electionService.getElectionById(electionId);
        if (electionOpt.isEmpty()) {
            return ResponseEntity
                .status(HttpStatus.NOT_FOUND)
                .body(new ErrorResponse(
                    404,
                    "Not Found",
                    "Election not found: " + electionId,
                    request.getRequestURI()
                ));
        }
        
        Election election = electionOpt.get();
        
        // Validar que la elección está activa
        if (!election.isActiveForVoting()) {
            return ResponseEntity
                .status(HttpStatus.BAD_REQUEST)
                .body(new ErrorResponse(
                    400,
                    "Bad Request",
                    "Election is not active for voting",
                    request.getRequestURI()
                ));
        }
        
        // Validar que el usuario no ha votado ya
        if (electionService.hasUserVoted(electionId, user.id())) {
            return ResponseEntity
                .status(HttpStatus.CONFLICT)
                .body(new ErrorResponse(
                    409,
                    "Conflict",
                    "User has already voted in this election",
                    request.getRequestURI()
                ));
        }
        
        // Validar que la opción existe
        if (voteRequest.encryptedPayload() == null && (voteRequest.optionId() == null || election.getOptionById(voteRequest.optionId()) == null)) {
            return ResponseEntity
                .status(HttpStatus.BAD_REQUEST)
                .body(new ErrorResponse(
                    400,
                    "Bad Request",
                    "Invalid option ID or missing encrypted payload",
                    request.getRequestURI()
                ));
        }
        
        try {
            byte[] voteBytes;
            String optionIdForRegistration = "ENCRYPTED";

            if (voteRequest.encryptedPayload() != null) {
                // Voto cifrado en cliente (RSA)
                Map<String, Object> voteData = new HashMap<>();
                voteData.put("electionId", electionId);
                voteData.put("encryptedVote", voteRequest.encryptedPayload());
                voteData.put("userId", user.id());
                voteData.put("timestamp", Instant.now().toString());
                
                voteBytes = objectMapper.writeValueAsBytes(voteData);
            } else {
                // Voto plano (Legacy/Dev)
                optionIdForRegistration = voteRequest.optionId();
                Map<String, Object> voteData = Map.of(
                    "electionId", electionId,
                    "optionId", voteRequest.optionId(),
                    "userId", user.id(),
                    "timestamp", Instant.now().toString(),
                    "comment", voteRequest.comment() != null ? voteRequest.comment() : ""
                );
                voteBytes = objectMapper.writeValueAsBytes(voteData);
            }
            
            // Cifrar y almacenar voto
            String blobId = storageService.storeEncrypted(electionId, voteBytes);
            logger.info("Vote encrypted and stored: blobId={}", blobId);
            
            // Generar commitment hash
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            byte[] hash = digest.digest(voteBytes);
            String commitment = Base64.getEncoder().encodeToString(hash);
            
            // Registrar en blockchain
            String transactionId = fabricService.emitVote(commitment, electionId);
            logger.info("Vote registered in blockchain: txId={}", transactionId);
            
            // Registrar voto en el servicio de elecciones
            electionService.registerVote(electionId, user.id(), optionIdForRegistration, blobId, transactionId);
            
            // Crear recibo
            String verificationCode = generateVerificationCode();
            Receipt receipt = Receipt.of(electionId, user.id(), transactionId, verificationCode);
            
            // Crear response
            VoteSubmissionResponse response = new VoteSubmissionResponse(
                transactionId,
                electionId,
                Instant.now(),
                commitment,
                blobId,
                true,
                "Vote submitted successfully"
            );
            
            logger.info("Vote processed successfully for user: {} in election: {}", 
                user.username(), electionId);
            
            return ResponseEntity
                .status(HttpStatus.CREATED)
                .body(response);
            
        } catch (JsonProcessingException e) {
            logger.error("Error serializing vote data", e);
            return ResponseEntity
                .status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(new ErrorResponse(
                    500,
                    "Internal Server Error",
                    "Error processing vote data",
                    request.getRequestURI()
                ));
        } catch (Exception e) {
            // Handle case where user already voted on blockchain but local DB is out of sync
            if (e.getMessage() != null && e.getMessage().contains("already voted")) {
                logger.warn("User {} already voted in election {} on blockchain. Syncing local state.", user.username(), electionId);
                
                // Sync local state
                electionService.registerVote(electionId, user.id(), voteRequest.optionId());
                
                return ResponseEntity
                    .status(HttpStatus.CONFLICT)
                    .body(new ErrorResponse(
                        409,
                        "Conflict",
                        "User has already voted in this election",
                        request.getRequestURI()
                    ));
            }

            logger.error("Error submitting vote", e);
            return ResponseEntity
                .status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(new ErrorResponse(
                    500,
                    "Internal Server Error",
                    "Error submitting vote: " + e.getMessage(),
                    request.getRequestURI()
                ));
        }
    }

    /**
     * Cerrar una elección (solo ADMIN)
     * POST /api/v1/elections/{id}/close
     * 
     * @param electionId ID de la elección a cerrar
     * @param authHeader Authorization header con JWT
     * @param request HTTP request
     * @return Resumen del cierre
     */
    @PostMapping("/{id}/close")
    public ResponseEntity<?> closeElection(
            @PathVariable("id") String electionId,
            @Valid @RequestBody es.tfg.votacion.dto.CloseElectionRequest closeRequest,
            @RequestHeader(value = "Authorization", required = false) String authHeader,
            HttpServletRequest request) {
        
        logger.info("Closing election: {}", electionId);
        
        // Validar autenticación y permisos ADMIN
        User user = validateAdminAccess(authHeader, request);
        if (user == null) {
            return ResponseEntity
                .status(HttpStatus.FORBIDDEN)
                .body(new ErrorResponse(
                    403,
                    "Forbidden",
                    "Admin access required",
                    request.getRequestURI()
                ));
        }
        
        Optional<Election> electionOpt = electionService.getElectionById(electionId);
        if (electionOpt.isEmpty()) {
            return ResponseEntity
                .status(HttpStatus.NOT_FOUND)
                .body(new ErrorResponse(
                    404,
                    "Not Found",
                    "Election not found: " + electionId,
                    request.getRequestURI()
                ));
        }
        
        Election election = electionOpt.get();
        if (election.status() != ElectionStatus.ACTIVE) {
             return ResponseEntity
                .status(HttpStatus.BAD_REQUEST)
                .body(new ErrorResponse(
                    400,
                    "Bad Request",
                    "Election is not active",
                    request.getRequestURI()
                ));
        }

        try {
            Election closed = electionService.closeElection(electionId, closeRequest.privateKey());
            
            Map<String, Object> response = Map.of(
                "electionId", electionId,
                "status", closed.status(),
                "totalVotes", closed.totalVotes(),
                "closedAt", LocalDateTime.now(),
                "closedBy", user.username()
            );
            
            logger.info("Election closed: {} by {}", electionId, user.username());
            return ResponseEntity.ok(response);
            
        } catch (Exception e) {
            logger.error("Error closing election", e);
            return ResponseEntity
                .status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(new ErrorResponse(
                    500,
                    "Internal Server Error",
                    "Error closing election",
                    request.getRequestURI()
                ));
        }
    }

    /**
     * Obtener resultados de una elección (ADMIN/AUDITOR)
     * GET /api/v1/elections/{id}/results
     * 
     * @param electionId ID de la elección
     * @param authHeader Authorization header con JWT
     * @param request HTTP request
     * @return Resultados de la votación
     */
    @GetMapping("/{id}/results")
    public ResponseEntity<?> getElectionResults(
            @PathVariable("id") String electionId,
            @RequestHeader(value = "Authorization", required = false) String authHeader,
            HttpServletRequest request) {
        
        logger.info("Fetching results for election: {}", electionId);
        
        // Validar autenticación y permisos
        User user = validateAdminOrAuditorAccess(authHeader, request);
        if (user == null) {
            return ResponseEntity
                .status(HttpStatus.FORBIDDEN)
                .body(new ErrorResponse(
                    403,
                    "Forbidden",
                    "Admin or Auditor access required",
                    request.getRequestURI()
                ));
        }
        
        Optional<Election> electionOpt = electionService.getElectionById(electionId);
        if (electionOpt.isEmpty()) {
            return ResponseEntity
                .status(HttpStatus.NOT_FOUND)
                .body(new ErrorResponse(
                    404,
                    "Not Found",
                    "Election not found: " + electionId,
                    request.getRequestURI()
                ));
        }
        
        Election election = electionOpt.get();
        
        // Solo mostrar resultados si está cerrada
        if (election.status() != ElectionStatus.CLOSED && 
            election.status() != ElectionStatus.COMPLETED) {
            return ResponseEntity
                .status(HttpStatus.BAD_REQUEST)
                .body(new ErrorResponse(
                    400,
                    "Bad Request",
                    "Election must be closed to view results",
                    request.getRequestURI()
                ));
        }
        
        Map<String, Integer> results = electionService.getElectionResults(electionId);
        int totalVotes = election.totalVotes();
        
        List<ElectionResultsResponse.OptionResult> optionResults = election.options().stream()
            .map(option -> {
                int votes = results.getOrDefault(option.optionId(), 0);
                double percentage = totalVotes > 0 ? (votes * 100.0 / totalVotes) : 0.0;
                return new ElectionResultsResponse.OptionResult(
                    option.optionId(),
                    option.title(),
                    votes,
                    percentage
                );
            })
            .toList();
        
        ElectionResultsResponse response = new ElectionResultsResponse(
            electionId,
            election.title(),
            election.status(),
            Instant.now(),
            totalVotes,
            optionResults,
            "blockchain-audit-trail-" + electionId
        );
        
        logger.info("Results fetched for election: {} by {}", electionId, user.username());
        return ResponseEntity.ok(response);
    }

    /**
     * Valida acceso ADMIN
     */
    private User validateAdminAccess(String authHeader, HttpServletRequest request) {
        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            return null;
        }
        
        String token = authHeader.substring(7);
        User user = authService.validateJwtToken(token);
        
        if (user == null || !authService.hasRole(user, es.tfg.votacion.model.UserRole.ADMIN)) {
            return null;
        }
        
        return user;
    }

    /**
     * Valida acceso ADMIN o AUDITOR
     */
    private User validateAdminOrAuditorAccess(String authHeader, HttpServletRequest request) {
        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            return null;
        }
        
        String token = authHeader.substring(7);
        User user = authService.validateJwtToken(token);
        
        if (user == null || !authService.hasAnyRole(user, 
                es.tfg.votacion.model.UserRole.ADMIN, 
                es.tfg.votacion.model.UserRole.AUDITOR)) {
            return null;
        }
        
        return user;
    }

    /**
     * Genera un código de verificación aleatorio
     */
    private String generateVerificationCode() {
        String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
        StringBuilder code = new StringBuilder();
        Random random = new Random();
        
        for (int i = 0; i < 12; i++) {
            code.append(chars.charAt(random.nextInt(chars.length())));
        }
        
        return code.toString();
    }
}